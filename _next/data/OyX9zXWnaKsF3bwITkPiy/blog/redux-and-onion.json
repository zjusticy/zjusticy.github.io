{"pageProps":{"post":{"title":"Redux and the onion model: a simple guidance","date":"2020-05-20T23:39:33.169Z","description":"Fundamental knowledge of redux and an simple but educational example for onion model","slug":"redux-and-onion","content":"\n## The prerequisite\n\n\n### 1. Javascript\n\n### 2. Compose\n\n> Composes functions from right to left.\n\nCombining functions, connecting functions in series for execution. Just like domino, the first function is pushed down, and other functions are also executed.\n\nFirst we look at a simple example.\n\n```js\n// Equation: f(x) = (x + 100) * 2 - 100\nconst add = a => a + 100;\nconst multiple = m => m * 2;\nconst subtract = s => s - 100;\n\n// Deeply nested function\nsubtract(multiple(add(200)));  //500\n```\n\nThe execution result of the above example is: 500\n\nCompose actually implements the concatenation of all functions through the reduce () method. The deep nested function mode is not directly used, which enhances the code readability.\n\n```js\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n```\n\n```\ncompose(subtract, multiple, add)(200);\n```\n\n### 3. Currying\n\n> Currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument\n\nLet the codes explain themselves:\n\n```js\n// Equation: f(x, y, z) = (x + 100) * y - z;\n\nconst fn = (x, y, z) => (x + 100) * y - z;\nfn(200, 2, 100);\n\n// Can be implemented as below \n\nconst fn = function(x) { \n  return function(y) { \n    return function(z) { \n      return (x + 100) * y - z; \n    }\n  } \n}\n\n\n// The implementation of Currying uses a single \n// parameter anonymous function wrapped in \n// layers to implement the same function above\n\nconst fn = x => y => z => (x + 100) * y - z;\nfn(200)(2)(100);  //500\n```\n\n* Currying only accepts single parameter.\n\n## Why dispatch needs middleware\n\n```\n\n --------  callack   ----------  action\n| Button | ------>  | Dispatch | ------           \n --------            ----------       |\n                                      |\n                                      |\n --------   state    ----------       |\n|  View  | <------  |  Reducer | <-----           \n --------            ----------             \n         \n```\n\nThe above figure shows a simple synchronous data flow scenario in redux. After clicking the button, an action is dispatched in the callback. After the reducer receives the action, it updates the state and notifies the view to re-render. One-way data flow, it looks no problem. However, if you need to print every action information for debugging, you have to change the dispatch or reducer code to make it have the function of printing the log; for example, after clicking the button, you need to go to the server to request data first. In order to re-render the view, at this time we hope that the dispatch or reducer has the function of asynchronous request; for example, after asynchronously requesting the data, print a log, request the data again, print the log again, and render ...\n\nIn the face of various business needs, simply modifying the code of dispatch or reducer is obviously not universal. What we need is a combinable, freely pluggable plug-in mechanism. This redux draws lessons from onion model in  [koa](https://link.zhihu.com/?target=http%3A//koa.bootcss.com/) to solve the problem. Koa is a NodeJS framework for building web applications. \n\n\n## Source code analysis of “applyMiddleware”\n\nThe code of applyMiddleware function is short, but it is the most essence of Redux. It allows Redux to insert the side effects in the process of action transmission while maintaining \"self-functional purity\".\n\nA piece of code is used for example before the diagram. We will understand applyMiddleware's onion model mechanism around this code:\n\n```js\nfunction M1(store) {\n  return function(next) {\n    return function(action) {\n      // M1 side effect\n      console.log('A middleware1 starts');\n      next(action)\n      console.log('B middleware1 ends');\n    };\n  };\n}\n\nfunction M2(store) {\n  return function(next) {\n    return function(action) {\n      // M2 side effect\n      console.log('C middleware2 starts');\n      next(action)\n      console.log('D middleware2 ends');\n    };\n  };\n}\n\nfunction M3(store) {\n  return function(next) {\n    return function(action) {\n      // M3 side effect\n      console.log('E middleware3 starts');\n      next(action)\n      console.log('F middleware3 ends');\n    };\n  };\n}\n\nfunction reducer(state, action) {\n  if (action.type === 'MIDDLEWARE_TEST') {\n    console.log('======= G =======');  \n  }\n  return {};\n}\n\nvar store = Redux.createStore(\n  reducer,\n  Redux.applyMiddleware(\n    M1,\n    M2,\n    M3\n  )\n);\n\nstore.dispatch({ type: 'MIDDLEWARE_TEST' });\n```\n\nThe onion model of the above code is as follows:\n\n```\n            --------------------------------------\n            |            middleware1              |\n            |    ----------------------------     |\n            |    |       middleware2         |    |\n            |    |    -------------------    |    |\n            |    |    |  middleware3    |    |    |\n            |    |    |                 |    |    |\n          next next next  ———————————   |    |    |\ndispatch  —————————————> |  reducer  | — Ending ->|\nnextState <————————————— |     G     |  |    |    |\n            | A  | C  | E ——————————— F |  D |  B |\n            |    |    |                 |    |    |\n            |    |    -------------------    |    |\n            |    ----------------------------     |\n            --------------------------------------\n\nSequence   A -> C -> E -> G -> F -> D -> B\n          \\---------------/   \\----------/\n                  ↓                ↓\n            Update state       Ending process\n```\n\n\nWe refer to each part of middleware that actually brings side effects (here side effects are good, all we need is side effects of middleware), called `M? Side effects`, and its function signature is `(action) => {}`.\n\n\nFor this sample code, the running process of the onion model of Redux middleware is:\n\nThe user dispatches action → action to pass the M1 side effects → print A → execute M1 next (this next points to M2 side effects) → print C → execute M2 next (this next points to M3 side effects) → print E → execute M3 next (this next Point to `store.dispatch`) → Return to M3 side effect printing F after execution completion → Return to M2 print E → Return to M1 side effect printing B-> dispatch execution is completed.\n\nSo the question is, how does the next of M1 M2 M3 bind?\n\nAnswer: Currying binding, the complete function signature of a middleware is `store => next => action {}`, but the last executed onion model only has action left, and the outer store and next go through Curry The corresponding function is bound, and then look at how next is bound.\n\n```js\nconst store = createStore(...args)\nlet dispatch = store.dispatch\nlet chain = []\nconst middlewareAPI = {\n    getState: store.getState,\n    dispatch: (...args) => dispatch(...args)\n}\nchain = middlewares.map(middleware => middleware(middlewareAPI)) // bind {dispatch和getState}\ndispatch = compose(...chain)(store.dispatch) // bind next\n```\n\nThe key point is the two bingding sentences. Let ’s look at the first sentence:\n\n```js\nchain = middlewares.map(middleware => middleware(middlewareAPI)) // bind {dispatch和getState}\n```\n\nWhy bind `getState`? Because middleware needs to get the current state at any time. Why should it get `dispatch`? Because there may be actions dispatching (such as redux-thunk) in the middleware, currying this map function binds `getState` and `dispatch`.\n\nNext  `dispatch = compose(...chain)(store.dispatch) `. The function of compose is, from right to left, the return value on the right is passed in as a parameter on the left, wrapped in layers, as we discussed above.\n\nIt is equivalent to: \n\n```js\ndispatch = MC1(MC2(MC3(store.dispatch)))\n\n```\n\nMC is the element in the chain, yes, this is another currying.\n\nAt this point, the truth is clear. Dispatch made a small contribution and did two things: 1 \\. Binding next in each middleware. 2 \\. An interface is exposed for receiving actions. \n\n## Detail\n\nAfter compose, all the middleware is connected in series, but there is still a problem we need to dig. Every middleware can access the store, which is the variable in middlewareAPI, so you can get the dispatch method of the store. Is there a difference to use `store.dispatch()` instead of `next()`?\n\n```js\n// The wrong version\n\nconst middlewareAPI = { \n  getState: store.getState, \n  dispatch: store.dispatch \n}\n\n// The correct version\n\nconst middlewareAPI = { \n  getState: store.getState, \n  dispatch: (...args) => dispatch(...args) \n}\n```\n\nIf directly written as `store.dispatch`, then dispatch an action in a middleware (except the last one, the last middleware is the original `store.dispatch`), such as redux-thunk:\n\n```js\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n```\n\nIt is to intercept the action with the function type. If this actionCreator is a fuction to fetch online data then dispatch a new action accordingly and we use `store.dispatch` instead of `dispatch = MC1(MC2(MC3(store.dispatch)))`, then this action has gone through `store.dispatch` without any middleware decoration, which is obviously not acceptable. The flow can be demonstrated as below:\n\n```\n// The wrong version using store.dispatch\n\nSequence   A -> C -> E -> G -> F -> D -> B\n                     |\n                     ↓                \n               dispatch action -> G\n\n\n// The correct version using \n// dispatch = MC1(MC2(MC3(store.dispatch)))\n\nSequence   A -> C -> E -> G -> F -> D -> B\n                     |\n                     ↓                \n               dispatch action -> A -> C -> E -> G ->...\n```\n\n\n## Reference\n\n*   [https://zhuanlan.zhihu.com/p/20597452](https://zhuanlan.zhihu.com/p/20597452)\n\n*   [https://github.com/kenberkeley/redux-simple-tutorial/blob/master/redux-advanced-tutorial.md](https://github.com/kenberkeley/redux-simple-tutorial/blob/master/redux-advanced-tutorial.md)\n\n*   [https://juejin.im/post/5859edb98d6d810065c8f28a](https://juejin.im/post/5859edb98d6d810065c8f28a)\n"}},"__N_SSG":true}